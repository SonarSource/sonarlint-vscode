/* --------------------------------------------------------------------------------------------
 * SonarLint for VisualStudio Code
 * Copyright (C) 2017-2025 SonarSource SA
 * sonarlint@sonarsource.com
 * Licensed under the LGPLv3 License. See LICENSE.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

'use strict';

import * as vscode from 'vscode';
import { FindingsTreeDataProvider } from '../findings/findingsTreeDataProvider';

export class TaintVulnerabilityDecorator {
  private static _instance: TaintVulnerabilityDecorator;
  private readonly decorationType = vscode.window.createTextEditorDecorationType({
    isWholeLine: false,
    rangeBehavior: vscode.DecorationRangeBehavior.ClosedOpen,
    textDecoration: `wavy underline var(--vscode-editorWarning-foreground)`,
    overviewRulerColor: new vscode.ThemeColor('editorWarning.foreground'),
    overviewRulerLane: vscode.OverviewRulerLane.Right
  });

  static init() {
    this._instance = new TaintVulnerabilityDecorator();
  }

  static get instance(): TaintVulnerabilityDecorator {
    return TaintVulnerabilityDecorator._instance;
  }

  constructor() {
    // Update decorations when the active editor changes
    vscode.window.onDidChangeActiveTextEditor(editor => {
      if (editor) {
        this.updateDecorations(editor);
      }
    });

    // Track content changes and update decorations
    vscode.workspace.onDidChangeTextDocument(event => {
      const editor = vscode.window.activeTextEditor;
      if (editor && event.document === editor.document) {
        // Adjust ranges based on content changes
        const uri = editor.document.uri.toString();
        let taints = FindingsTreeDataProvider.instance.getTaintVulnerabilitiesForFile(uri) || [];

        event.contentChanges.forEach(change => {
          const newlineCount = (change.text.match(/\n/g) || []).length;
          const lineDelta = newlineCount - (change.range.end.line - change.range.start.line);
          taints = taints.map(taint => {
            if (change.range.end.line < taint.range.start.line) {
                // line number change
                taint.range = taint.range.with({
                    start: taint.range.start.translate(lineDelta, 0),
                    end: taint.range.end.translate(lineDelta, 0)
                });
                return taint;
            } else if (
              // offset change
              taint.range.start.isAfter(change.range.end)
            ) {
              const offsetDelta = change.text.length - (change.range.end.character - change.range.start.character);
              taint.range = taint.range.with({
                start: taint.range.start.translate(0, offsetDelta),
                end: taint.range.end.translate(0, offsetDelta)
              });
              return taint;
            }
            return taint; // No change needed
          });
        });

        this.updateDecorations(editor);
      }
    });
  }

  private updateDecorations(editor: vscode.TextEditor) {
    const uri = editor.document.uri.toString();
    const taints = FindingsTreeDataProvider.instance.getTaintVulnerabilitiesForFile(uri) || [];

    const decorations = taints.map(taint => ({
      range: taint.range,
      hoverMessage: (() => {
        const {command, ...rest} = taint;
        const md = new vscode.MarkdownString('$(lock) SonarQube: ' + taint.message + '. [Show Details](command:SonarQube.ShowAllInfoForFinding?' + encodeURIComponent(JSON.stringify(rest)) + ')');
        md.isTrusted = true;
        md.supportThemeIcons = true;
        return md;
      })()
    }));

    editor.setDecorations(this.decorationType, decorations);
  }

  updateTaintVulnerabilityDecorationsForFile(uri: vscode.Uri) {
    // Update decorations if this is the active editor
    const editor = vscode.window.activeTextEditor;
    if (editor && editor.document.uri.toString() === uri.toString()) {
      this.updateDecorations(editor);
    }
  }
}