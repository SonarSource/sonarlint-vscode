/* --------------------------------------------------------------------------------------------
 * SonarLint for VisualStudio Code
 * Copyright (C) 2017-2025 SonarSource SÃ rl
 * sonarlint@sonarsource.com
 * Licensed under the LGPLv3 License. See LICENSE.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

'use strict';

import * as vscode from 'vscode';
import { FindingsTreeDataProvider } from '../findings/findingsTreeDataProvider';
import { isFocusingOnNewCode } from '../settings/settings';
import { FindingNode } from '../findings/findingTypes/findingNode';

export class TaintVulnerabilityDecorator {
  private static _instance: TaintVulnerabilityDecorator;
  private readonly yellowSquigglyDecorationType = vscode.window.createTextEditorDecorationType({
    isWholeLine: false,
    rangeBehavior: vscode.DecorationRangeBehavior.ClosedOpen,
    textDecoration: `wavy underline var(--vscode-editorWarning-foreground)`,
    overviewRulerColor: new vscode.ThemeColor('editorWarning.foreground'),
    overviewRulerLane: vscode.OverviewRulerLane.Right
  });

  private readonly hintDecorationType = vscode.window.createTextEditorDecorationType({
    isWholeLine: false,
    rangeBehavior: vscode.DecorationRangeBehavior.ClosedOpen,
    textDecoration: 'none',
    border: '1px dotted var(--vscode-editorHint-foreground)',
    borderSpacing: '2px',
    borderWidth: '0 0 1px 0'
  });

  static init() {
    this._instance = new TaintVulnerabilityDecorator();
  }

  static get instance(): TaintVulnerabilityDecorator {
    return TaintVulnerabilityDecorator._instance;
  }

  constructor() {
    // Update decorations when the active editor changes
    vscode.window.onDidChangeActiveTextEditor(editor => {
      if (editor) {
        this.updateDecorations(editor);
      }
    });

    // Track content changes and update decorations
    vscode.workspace.onDidChangeTextDocument(event => {
      const editor = vscode.window.activeTextEditor;
      if (editor && event.document === editor.document) {
        // Adjust ranges based on content changes
        const uri = editor.document.uri.toString();
        let taints = FindingsTreeDataProvider.instance.getTaintVulnerabilitiesForFile(uri) || [];

        event.contentChanges.forEach(change => {
          const newlineCount = (change.text.match(/\n/g) || []).length;
          const lineDelta = newlineCount - (change.range.end.line - change.range.start.line);
          taints = taints.map(taint => {
            if (change.range.end.line < taint.range.start.line) {
              // line number change
              taint.range = taint.range.with({
                start: taint.range.start.translate(lineDelta, 0),
                end: taint.range.end.translate(lineDelta, 0)
              });
              return taint;
            } else if (
              // offset change
              taint.range.start.isAfter(change.range.end)
            ) {
              const offsetDelta = change.text.length - (change.range.end.character - change.range.start.character);
              taint.range = taint.range.with({
                start: taint.range.start.translate(0, offsetDelta),
                end: taint.range.end.translate(0, offsetDelta)
              });
              return taint;
            }
            return taint; // No change needed
          });
        });

        this.updateDecorations(editor);
      }
    });
  }

  private updateDecorations(editor: vscode.TextEditor) {
    // Clear all decorations first
    editor.setDecorations(this.yellowSquigglyDecorationType, []);
    editor.setDecorations(this.hintDecorationType, []);

    const uri = editor.document.uri.toString();
    const taints = FindingsTreeDataProvider.instance.getTaintVulnerabilitiesForFile(uri) || [];

    const createDecoration = (taint: FindingNode) => ({
      range: taint.range,
      hoverMessage: (() => {
        // need to remove command from taint object to avoid circular reference
        const { command, ...taintWithoutCommand } = taint;
        const md = new vscode.MarkdownString(
          `$(lock) SonarQube: ${
            taint.message
          }. [Show Details](command:SonarQube.ShowAllInfoForFinding?${encodeURIComponent(JSON.stringify(taintWithoutCommand))})`
        );
        md.isTrusted = true;
        md.supportThemeIcons = true;
        return md;
      })()
    });

    // Categorize taints by new code status
    if (isFocusingOnNewCode()) {
      const newCodeTaints = taints.filter(taint => taint.isOnNewCode).map(createDecoration);
      const oldCodeTaints = taints.filter(taint => !taint.isOnNewCode).map(createDecoration);
      // Apply different decorations for new and old code
      editor.setDecorations(this.yellowSquigglyDecorationType, newCodeTaints);
      editor.setDecorations(this.hintDecorationType, oldCodeTaints);
    } else {
      editor.setDecorations(this.yellowSquigglyDecorationType, taints);
    }


  }

  updateTaintVulnerabilityDecorationsForFile(uri?: vscode.Uri) {
    const editor = vscode.window.activeTextEditor;
    const isActiveEditorUriSameAsUri = uri ? editor?.document.uri.toString() === uri.toString() : true;
    if (editor && isActiveEditorUriSameAsUri) {
      this.updateDecorations(editor);
    }
  }
}
